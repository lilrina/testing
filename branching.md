https://spin.atomicobject.com/2018/10/10/git-branching-strategy/  by Joe Chrysler

https://barro.github.io/2016/02/a-succesful-git-branching-model-considered-harmful/ by Jussi Judin

https://nvie.com/posts/a-successful-git-branching-model/ by Vincent Driessen

###### Summary of Three Branching Strategies

Joe Chrysler's branching strategy calls for a new branch for any change, no matter how small it is. He also advocates for "Rebase Early & Often". He backs up his branches by adding a new branch or tag before doing rebasing. Joe doesn't follow hard rules on where new branches must be descended from: instead he tries to guess the future in order to decide branch lineage. If his guess goes wrong, he uses more advanced git concepts to clean things up.

Jussi Judin uses the "cactus model". The only place a new branch is permitted to start is from the master branch, and the new branches never get merged back in. Feature development takes place on the master branch. Local branches are allowed, but they are short lived and they are frequently rebased. Changes should be integrated back into master as soon as they are ready, and everyone should make sure they have an up-to-date copy of master. Official release versions are branched out from master (as dead-ends). If a hotfix is made on a release branch, the fix is just "cherry-picked" back to master; there is never any merging. Using git rebase and git cherry-pick instead of git merge creates a linear commit history.

Vincent Driessen's popular branching strategy was given in class as a reading assignment. Vincent has two branches that last forever: master and develop. The master branch is for production-ready code only. The develop branch is the parent branch of feature branches which get merged back into develop when these features are ready. The feature branches (just mentioned as descendants of develop), release branches, and hotfix branches are short-lived. When develop is almost at the state of release-ready, it is branched into a release branch, where minor issues are finalized (but no big features are added). When the release branch is done, it is merged back into master where it is given a tag with the release version number. The release branch is also merged back into develop so that the develop branch has all the up-to-date fixes. Finally, the hotfix branches split from master when there is an emergency bug in the production code. Once the fix is made, the hotfix branch is merged back into both master and develop. All of these rules are strictly followed at all times so that everyone knows the purpose of each branch.

###### Our Feelings About the Above Branching Strategies

Our team didn't consider using Joe Chrysler's strategy. For one, it makes use of frequent rebasing, and we don't want to use rebasing at all because it isn't permitted for this project and it can obscure the history of a project. However, we are using Joe's idea of creating a new branch for almost any change. This is almost by default: the 3 members of our team who are making changes are all going to make a separate branch for separate, small issues they have identified. We don't need to backup branches because we aren't using Joe's complicated ideas about rebasing. The branches will already exist in the commit history.

Again, we didn't even consider using the cactus model presented by Jussi Judin. There is no merging in this model, and we want to play with merging. There **is** rebasing, and we aren't supposed to use rebasing. Cherry-picking is a more advanced concept than we have currently used, so we'd like to avoid that. We don't think feature development should take place on the master branch. The only aspect of the cactus model we use is by accident: all of our branches will be descended from the master branch. This is only because each team member is working on a separate issue branch, and the project is too small to care about a development branch.

We like Vincent Driessen's strategy, and would certainly consider using it for a more complicated, longer-running, more important project. We simply don't have enough commits to justify this careful approach. We aren't really making hotfixes to production-ready code, and it seems unlikely that this code is production-ready. For that reason, we also definitely don't need a release branch. I'm not sure that any of our code changes really qualify as features either. This is all just too fancy for this limited project.

###### Our Branching Strategy

Our branching strategy is very simple. Each of the three team members who are working on an issue creates a separate local branch while they work on the issue. When they have completed their work, they push that branch up to their github repository and issue a pull request to get the branch merged back into the master branch on the team's primary fork of the repository. We aren't doing any collaboration on issues, so there is no branching from these temporary local issue branches. Since the project is meant to use pull requests, all of the changes can be inspected and tested before being merged back into the master branch. Since our workflow is so simple (and our desire to modify RaiderPlanner is limited), we didn't want to put any more effort into a branching strategy than necessary.

Clearly, this would be an inadequate strategy for a complicated, long-running project. We don't like either of the first two strategies presented above. If we were invested in a project, we would attempt to use Vincent Dreissen's strategy. The discipline it enforces on the process seems to be very effective.